# 第二章 变量和基本类型

> 练习2.1：类型`int`、`long`、`long long`和`short`的区别是什么？无符号类型和带符号类型的区别是什么？

1. 一个`int`至少和一个`short`一样大，一个`long`至少和一个`int`一样大，一个`long long`至少和一个`long`一样大。
2. 除去布尔型和扩展的字符型之外，其他整型可以划分为带符号和无符号两种，带符号类型可以表示正数、负数和0，无符号整数则仅表示大于等于0的值。

> 练习2.2：计算按揭贷款时，对于利率、本金和付款分别应该选择何种数据类型？说明你的理由。

利率选用`double`，本金选用`double`，付款选用`double`。

选择数据类型的准则：

1. 当明确知晓数值不可能为负时，选择无符号数。
2. 使用`int`执行整数操作。在实际应用中，`short`常常太小，而`long`一般和`int`有一样的尺寸，如果你的数值超过了`int`的表示范围，选用`long long`。
3. 在算数表达式中不要使用`char`或`bool`，只有在存放字符或者布尔值时才使用它们。因为类型`char`在一些机器上是有符号的，而在另外一些机器上又是无符号的，所以如果使用`char`进行运算特别容易出现问题。如果你需要不大的整数，需要明确指出它的类型是`unsigned char`或者`signed char`。
4. 执行浮点运算选择`double`，因为`float`通常精度不够，而且双精度和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快，`long double`提供的精度在一般情况下是没有必要的，况且它带来的运动时消耗也是不容忽视的。

> 练习2.3：读程序写结果。
>
> ```C++
> unsigned u = 10, u2 = 42;
> std::cout << u2 - u << std::endl;
> std::cout << u - u2 << std::endl;
> 
> int i = 10, i2 = 42;
> std::cout << i2 - i << std::endl;
> std::cout << i - i2 << std::endl;
> std::cout << i - u << std::endl;
> std::cout << u - i << std::endl;
> ```

32

4294967264

32

-32

0

0

> 练习2.4：编写程序检查你的估计是否正确，如果不正确，请研读本节知道弄明白问题所在。

略。

> 练习2.5：指出下述字面值的数据类型并说明每一组内几种字面值的区别。
>
> ```C++
> (a)`a`,L`a`,"a",L"a"
> (b)10,10u,10L,10uL,012,0xC
> (c)3.14,3.14f,3.14l
> (d)10,10u,10.,10e-2
> ```

(a) 字符常量、宽字符常量、字符串字面值常量、宽字符串字面值常量

(b) int、unsigned int、long、unsigned long、八进制数字、十六进制数字

(c) double、float、long double

(d) int、unsigned int、double、double

> 练习2.6：下面两组定义是否有区别，如果有，请叙述之。
>
> ```C++
> int month = 9, day = 7;
> int month = 09, day = 07;
> ```

有区别，第一行是十进制数字，第二行是八进制数字。

> 练习2.7：下面字符值表示何种含义？他们各自的数据类型是什么？
>
> ```C++
> (a)"Who goes with F\145rgus?\012"
> (b)3.14e1L
> (c)1024f
> (d)3.14L
> ```

(a) "Who goes with Fergus?\n"字符串

(b) 3.14 long double

(c) 1024 float

(d) 3.14 long double

> 练习2.8：请利用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。

```C++
#include <iostream>
int main()
{
    std::cout << "\062\115\012" << std::endl;
    std::cout << "\062\t\115\012" << std::endl;
    return 0;
}

```

> 练习2.9：解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。
>
> ```c++
> (a)std::cin >> int input_value;
> (b)int i = {3.14};
> (c)double salary = wage = 9999.99;
> (d)int i = 3.14;
> ```

(a)操作符`>>`右侧为变量，而不是变量定义，修改为：

```C++
int input_value;
std::cin >> input_value;
```

(b) 初始值`3.14`在赋值给整型变量`i`的时候存在精度损失，因此编译器将报错。修改如下：

```c++
int i = 3.14;
```

(c)变量`wage`没有被定义，便被用来给变量`salary`进行初始化。修改如下：

```c++
double wage = 9999.99;
double salary = wage;
```

(d)发生隐式类型转换。

> 练习2.10：下列变量的初值分别是什么？
>
> ```c++
> std::string global_str;
> int global_int;
> int main()
> {
>     int local_int;
>     std::string local_str;
> }
> ```

变量`global_str`和变量`local_str`的初始值均为空字符串，变量`global_int`的初始值为0，变量`local_int`的初始值为未定义的。

> 练习2.11：指出下面的语句是声明还是定义。
>
> ```C++
> (a)extern int ix = 1024;
> (b)int iy;
> (c)extern int iz;
> ```

(a) 定义

(b) 定义

(c) 声明

> 练习2.12：请指出下面的名字中哪些是非法的。
>
> ```C++
> (a)int double = 3.14;
> (b)int _;
> (c)int catch-22;
> (d)int 1_or_2 = 1;
> (e)double Double = 3.14;
> ```

(a)不合法，`double`为C++保留的关键字

(b)合法。

(c)不合法，标识符只能由字母、数字和下划线组成，不包含连字符`-`。

(d)不合法，标识符只能以字母和下划线开头，不能以数字开头。

(e)合法。

> 练习2.13：下面程序中j的值是什么？
>
> ```C++
> int i = 42;
> int main()
> {
>  int i = 100;
>  int j = i;
> }
> ```

j的值是100。

> 练习2.14：下面的程序合法吗？如果合法，它将输出什么？
>
> ```C++
> int i = 100,sum = 0;
> for(int i = 0;i != 10; ++i)
>  sum += i;
> std::cout << i << " " << sum << std::endl;
> ```

合法，输出结果为：

100 45

> 练习2.15：下面哪个定义是不合法的？为什么？
>
> ```C++
> (a)int ival = 1.01;
> (b)int &rval1 = 1.01;
> (c)int &ival2 = ival;
> (d)int &rval3;
> ```

(a)合法，但是存在精度损失。

(b)不合法，不能将普通的引用绑定在字面值常量上。

(c)合法。

(d)不合法，引用必须进行初始化，因为引用是变量的别名，一旦将引用绑定在某个对象上就不能改变。

> 练习2.16：考察下面的所有赋值，然后回答：哪些赋值是不合法的，为什么，哪些赋值是合法的，它们执行了些什么操作？
>
> ```C++
> int i = 0, &r1 = i;
> double d = 0, &r2 = d;
> (a)r2 = 3.14159;
> (b)r2 = r1;
> (c)i = r2;
> (d)r1 = d;
> ```

(a)合法，给`d`赋值3.14159。

(b)合法，存在隐式类型转换。

(c)合法，将存在数据截断。

(d)合法，将存在数据截断。

> 练习2.17：执行下面的代码段将输出什么样的结果？
>
> ```c++
> int i, &ri = i;
> i = 5; ri = 10;
> std::cout << i << " " << ri << std::endl;
> ```

输出结果：

```C++
10 10
```

> 练习2.18：编写代码分别更改指针的值和指针所指对象的值。

```C++
// 改变指针的值
int main()
{
    int m = 3;
    int n = 5;
    int *pm = &m;
    pm = &n;
}
```

```C++
// 改变指针所指对象的值
int main()
{
    int m = 3;
    int *pm = &m;
    *pm = 4;
}
```

> 练习2.19：说明指针和引用的主要区别。

1. 引用是变量的别名，不是一个对象，指针是一个对象
2. 引用必须被初始化，一旦绑定到一个变量上，便不能被改变，但是指针不用必须初始化，指针指向的对象能改变。

> 练习2.20：请叙述下面这段代码的作用。
>
> ```C++
> int i = 42;
> int *pl = &i;
> *pl = *pl * *pl; 
> ```

计算变量`i`的平方，并将其赋值给变量`i`自身。

> 练习2.21：请解释下述定义。在这些定义中有非法的吗？如果有，为什么？
>
> ```C++
> int i = 0;
> (a)double *dp = &i;
> (b)int *ip = i;
> (c)int *p = &i;
> ```

(a)不合法，不能使用`int *`类型的变量初始化`double *`类型的变量。

(b)不合法，指针保存的是内存中的地址，不能是变量。

(c)合法。

> 练习2.22：假设`p`是一个`int`类型的指针，请说明下述代码的含义。
>
> ```C++
> if(p)  //...
> if(*p) //...
> ```

1. 判断指针`p`是否是空指针。
2. 判断指针`p`指向的是否为`0`。

> 练习2.23：给定指针`p`，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。

不能，因为信息不够。

> 练习2.24：下面这段代码中为什么`p`合法而`lp`非法？
>
> ```C++
> int i = 42;
> void *p = &i;
> long *lp = &i;
> ```

因为指针`p`是`void`类型的指针，任何类型的指针都能用来初始化该类型指针，但是不能用`int *`类型的变量初始化`long *`类型的变量。

> 练习2.25：说明下列变量的类型和值。
>
> ```C++
> (a)int *ip, i, &r = i;
> (b)int i, *ip = 0;
> (c)int *ip, ip2;
> ```

(a)`ip`是指向`int`的指针，`i`是`int`类型的对象，`r`是变量`i`的引用。

(b)`i`是`int`类型的变量，`ip`是指向`int`类型的指针。

(c)`ip`是指向`int`类型的指针，`ip2`是`int`类型的对象。

> 练习2.26：下面哪些句子是合法的？如果有不合法的句子，请说明为什么？
>
> ```C++
> (a)const int buf;
> (b)int cnt = 0;
> (c)const int sz = cnt;
> (d)++cnt;++sz;
> ```

(a)不合法，`const`类型的变量必须被初始化。

(b)合法。

(c)合法。

(d)`++cnt;`合法，`++sz;`不合法，因为`const`类型变量的值不能被修改。

> 练习2.27：下面的哪些初始化是合法的？请说明原因。
>
> ```C++
> (a)int i = -1, &r = 0;
> (b)int *const p2 = &i2;
> (c)const int i = -1,&r = 0;
> (d)const int * const p3 = &i2;
> (e)const int *p1 = &i2;
> (f)const int &const r2;
> (g)const int i2 = i, &r = i;
> ```

(a)变量`i`是合法的，变量`r`是不合法的，引用`r`必须绑定在一个变量上。

(b)合法。

(c)合法。

(d)合法。

(e)合法。

(f)不合法，引用`r2`不是一个对象，因此不能被声明为`const`类型的。

(g)合法。

> 练习2.28：说明下面的这些定义是什么意思，挑出其中不合法的。
>
> ```C++
> (a)int i, *const cp;
> (b)int *p1, *const p2;
> (c)const int ic, &r = ic;
> (d)const int * const p3;
> (e)const int *p;
> ```

(a)变量`i`是一个`int`类型的对象，`cp`是一个指向`int`类型的常量指针，因为`cp`本身是一个常量，所以必须进行初始化，不合法。

(b)`p1`是一个指向`int`类型的指针，`p2`是一个指向`int`类型的常量指针，因为`p2`本身是一个常量，所以必须进行初始化，不合法。

(c)`ic`是一个常量，必须进行初始化，不合法，`r`是一个常量引用，合法。

(d)`p3`是一个指向常量的常量指针，必须进行初始化，不合法。

(e)`p`是一个指向常量的指针，合法。

> 练习2.29：假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。
>
> ```C++
> (a)i = ic;
> (b)p1 = p3;
> (c)p1 = &ic;
> (d)p3 = &ic;
> (e)p2 = p1;
> (f)ic = *p3;
> ```

(a)合法。

(b)不合法，`p3`是一个指向常量的指针。

(c)不合法，不能用普通指针`p1`指向常量`ic`。

(d)不合法，`p3`是一个常量，初始化之后不能被更改。

(e)不合法，`p2`是一个常量，初始化之后不能被更改。

(f)不合法，`ic`是一个常量，在初始化之后不能被赋值。

> 练习2.30：对于下面的这些语句，请说明对象被声明成顶层const还是底层const：
>
> ```C++
> (a)const int v2 = 0;
> (b)int v1 = v2;
> (c)int *p1 = &v1, &r1 = v1;
> (d)const int *p2 = &v2, *const p3 = &i, &r2 = v2;
> ```

(a)`v2`：底层const。

(b)`v1`既不是底层const也不是顶层const。

(c)`p1`既不是底层const也不是顶层const，`r1`既不是底层const也不是顶层const。

(d)`p2`是底层const，`p3`既是底层const也是顶层const，`r2`是底层const。

> 练习2.31：假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说明顶层const和底层const在每个例子中有何体现。
>
> ```C++
> (a)r1 = v2;
> (b)p1 = p2; 
> (c)p2 = p1;
> (d)p1 = p3;
> (e)p2 = p3;
> ```

(a)合法，顶层const属性。

(b)不合法，在拷贝时要考虑底层const属性，const类型变量不能转换成非const类型变量。

(c)合法，非const类型变量可以转换成const类型变量。

(d)不合法，变量拷贝时可以忽略顶层const，不能忽略底层const。

(e)合法，变量拷贝时可以忽略顶层const，不能忽略底层const。

> 练习2.32：下面的代码是否合法？如果非法，请设法将其修改正确。
>
> ```C++
> int null = 0, *p = null;
> ```

不合法，因为指针保存的是地址，不能是对象，修改为：

```C++
int null = 0;
const int *p = null;

// 或者
int null = 0;
int *p = nullptr;
```

> 练习2.33：利用本节定义的变量，判断下列语句的运行结果。
>
> ```C++
> (a)a = 42; 
> (b)b = 42;
> (c)c = 42;
> (d)d = 42; 
> (e)e = 42; 
> (g)g = 42;
> ```

(a)给变量`a`赋值42。

(b)给变量`b`赋值42。

(c)给变量`c`赋值42。

(d)错误，不能将整型变量直接赋值给指针。

(e)错误，不能将整型变量直接赋值给指针。

(g)错误，不能将整型变量直接赋值给引用。

> 练习2.34：基于上一个练习中的变量和语句编写一段程序，输出复制前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。

略。

> 练习2.35：判断下列定义推断出的类型是什么，然后编写程序进行验证。
>
> ```C++
> const int i = 42;
> (a)auto j = i;
> (b)const auto &k = i;
> (c)auto *p = &i;
> (d)const auto j2 = i， &k2 = i;
> ```

(a)int类型

(b)int类型的常量引用

(c)指向常量int的指针

(d)int常量，int类型的常量引用

> 练习2.36：关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。
>
> ```C++
> int a= 3, b = 4;
> decltype(a) c = a;
> decltype((b)) d = a;
> ++c;
> ++d;
> ```

`a` int， `b` int，`c` int，`d` int类型的引用，绑定在`a`上，程序运行结束时的结果：

a为4，b为4，c为4，d为4。

> 练习2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果`i`是`int`，则表达式`i = x`的类型是`int&`。根据这一特点，请指出下面的代码中每一个变量的类型和值。
>
> ```C++
> int a = 3,b = 4;
> decltype(a) c = a;
> decltype(a = b)d = a;
> ```

a：int类型，值为3

b：int类型，值为4

c：int类型，值为3

d：int &，值为3

> 练习2.38：说明由`decltype`指定类型和由`auto`指定类型有何区别。请举出一个例子，`decltype`指定的类型与`auto`指定的类型不一样。

- 对顶层const和底层const的处理方式不同，auto会忽略顶层const，保留底层const，但是decltype会保留顶层const和底层const。
- 对引用的处理方式不同，decltype作用于引用时，推断的变量类型为引用，但是auto推断的类型为引用绑定的变量的类型。
- decltype作用于解引用和赋值表达式时的返回类型是引用。

```C++
// 相同
int a = 3;
decltype(a) b;
auto b = a;

// 不同
int a = 3;
int &ra = a;
decltype(ra) b = a;
auto b = ra;
```

> 练习2.39：编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分好会发生什么情况？记录下相关信息，以后可能会有用。
>
> ```C++
> struct Foo{ /*此处为空*/ }  // 注意：没有分号
> int main()
> {
>  return 0;
> }
> ```

略。

> 练习2.40：根据自己的理解写出Sales_data类，最好与书中的例子有所区别。

```C++
#include <string>
struct Sales_data
{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;  // C++11新标准允许成员变量进行类内初始化
};
```

> 练习2.41：使用你自己的Sales_data类重写1.5.1节（第20页）、1.5.2节（第21页）和1.6节（第22页）的练习。眼下先把Sales_data类的定义和main函数放在同一个文件中。

略。

> 练习2.42：根据你自己的理解重写一个Sales_data.h头文件，并以此为基础重做2.6.2节（第67页）的练习。

略。







